\textbf{问题}: 给定一个字符串$s$, 多次询问$[l, r]$区间的本质不同的子串个数, 可能强制在线.

\textbf{做法}: 考虑建出后缀自动机, 然后枚举右端点, 用线段树维护每个左端点的答案.

显然只有right集合在$[l, r]$中的串才有可能有贡献, 所以我们可以只考虑每个串最大的right.

每次右端点+1时找到它对应的结点$u$, 则$u$到根节点路径上的每个点, 它的right集合都会被$r$更新.

对于某个特定的左端点$l$, 我们需要保证本质不同的子串左端点不能越过它; 因此对于一个结点$p$, 我们知道它对应的子串长度$(val_{par_p}, val_p]$之后, 在$p$的right集合最大值减去对应长度, 这样对应的$l$内全部$+1$即可; 这样询问时就只需要查询$r$对应的线段树中$[l, r]$的区间和. (当然旧的right对应的区间也要减掉)

实际上可以发现更新时都是把路径分成若干个整段更新right集合, 因此可以用LCT维护这个过程.

时间复杂度$O(n\log ^ 2 n)$, 空间$O(n)$, 当然如果强制在线的话, 就把线段树改成主席树, 空间复杂度就和时间复杂度同阶了.

\inputminted{cpp}{../src/string/samlct.cpp}