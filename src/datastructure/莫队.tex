注意如果$n$和$q$不平衡, 块大小应该设为$\frac n {\sqrt q}$.

另外如果裸的莫队要卡常可以按块编号奇偶性分别对右端点正序或者倒序排序, 期望可以减少一半的移动次数.


\subsubsection{回滚莫队(无删除莫队)(待完成)}

\subsubsection{莫队二次离线}

适用范围: 询问的是点对相关(或者其它可以枚举每个点和区间算贡献)的信息, 并且可以离线; 更新时可以使用一些牺牲修改复杂度来改善询问复杂度的数据结构(如单点修改询问区间和).

先按照普通的莫队将区间排序. 考虑区间移动的情况, 以$(l, r)$向右移动右端点到$(l, t)$为例.

对于每个$i \in (r, t]$来说, 它都要对区间$[l, i)$算贡献. 可以拆成$[1, i)$和$[1, l)$两部分, 那么前一部分因为都是$i$和$[1, i)$做贡献的形式所以可以直接预处理.

考虑后一部分, $i$和$(1, l]$做贡献, 因为莫队的性质我们可以保证这样的询问次数不超过$O((n + m)\sqrt n)$, 因此我们可以对每个$l$记录下来哪些$i$要和它询问. 并且每次移动时询问的$i$都是连续的, 所以对每个$l$开一个vector记录下对应的区间和编号就行了.

剩余的三种情况(右端点左移或者移动左端点)都是类似的, 具体可以看代码.

例: Yuno loves sqrt technology II (询问区间逆序对数)

\inputminted{cpp}{../src/datastructure/莫队二次离线.cpp}

\subsubsection{带修莫队在线化 $O(n ^ {\frac 5 3})$}

最简单的带修莫队: 块大小设成$n^{\frac 2 3}$, 排序时第一关键字是左端点块编号, 第二关键字是右端点块编号, 第三关键字是时间. (记得把时间压缩成只有修改的时间.)

现在要求在线的同时支持修改, 仍然以$B = n^{\frac 2 3}$分一块, 预处理出两块之间的贡献, 那么预处理复杂度就是$O(n ^ {\frac 5 3})$.

修改时最简单的方法是直接把$n^{\frac 2 3}$个区间全更新一遍. 嫌慢的话可以给每个区间打一个懒标记, 询问的时候如果解了再更新区间的信息.

注意如果附加信息是可减的(比如每个数的出现次数), 那么就只需要存$O(n^{\frac 1 3})$个.

总复杂度仍然是$O(n^{\frac 5 3})$, 如果打懒标记的话是跑不太满的. 如果附加信息可减则空间复杂度是$O(n^{\frac 4 3})$, 否则和时间复杂度同阶.

\subsubsection{莫队二次离线 在线化 $O((n + m)\sqrt n)$}

和之前的道理是一样的, $i$和$[1, i)$的贡献这部分仍然可以预处理掉, 而前后缀对区间的贡献那部分只保存块端点处的信息.

按照莫队二次离线的转移方法操作之后发现只剩两边散块的贡献没有解决. 这时可以具体问题具体解决, 例如求逆序对的话直接预处理出排序后的数组然后归并即可.

时空复杂度均为$O(n\sqrt n)$.

以下代码以强制在线求区间逆序对为例(洛谷上被卡常了, 正常情况下极限数据应该在1.5s内.)

\inputminted{cpp}{../src/datastructure/莫队二次离线在线化.cpp}